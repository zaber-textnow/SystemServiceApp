//
//  route.swift
//  DeviceInfoSwift
//
//  Created by Zaber on 2/4/22.
//

import UIKit

/*
 * These numbers are used by reliable protocols for determining
 * retransmission behavior and are included in the routing structure.
 */

struct rt_metrics {
    var    rmx_locks: UInt32    /* Kernel leaves these values alone */
    var    rmx_mtu: UInt32    /* MTU for this path */
    var    rmx_hopcount: UInt32    /* max hops expected */
    var        rmx_expire: Int32    /* lifetime for route, e.g. redirect */
    var    rmx_recvpipe: UInt32    /* inbound delay-bandwidth product */
    var    rmx_sendpipe: UInt32    /* outbound delay-bandwidth product */
    var    rmx_ssthresh: UInt32    /* outbound gateway buffer limit */
    var    rmx_rtt: UInt32    /* estimated round trip time */
    var    rmx_rttvar: UInt32    /* estimated rtt variance */
    var    rmx_pksent: UInt32    /* packets sent using this route */
    var    rmx_filler: [UInt32]   /* will be used for T/TCP later */
}

/*
 * rmx_rtt and rmx_rttvar are stored as microseconds;
 */


let    RTM_RTTUNIT = 1000000    /* units for rtt, rttvar, as units per sec */



let    RTF_UP = 0x1        /* route usable */
let    RTF_GATEWAY = 0x2        /* destination is a gateway */
let    RTF_HOST = 0x4        /* host entry (net otherwise) */
let    RTF_REJECT = 0x8        /* host or net unreachable */
let    RTF_DYNAMIC = 0x10        /* created dynamically (by redirect) */
let    RTF_MODIFIED = 0x20        /* modified dynamically (by redirect) */
let    RTF_DONE = 0x40        /* message confirmed */
let    RTF_DELCLONE = 0x80        /* delete cloned route */
let    RTF_CLONING = 0x100        /* generate new routes on use */
let    RTF_XRESOLVE = 0x200        /* external daemon resolves name */
let    RTF_LLINFO = 0x400        /* generated by link layer (e.g. ARP) */
let    RTF_STATIC = 0x800        /* manually added */
let    RTF_BLACKHOLE = 0x1000        /* just discard pkts (during updates) */
let    RTF_NOIFREF = 0x2000        /* not eligible for RTF_IFREF */
let    RTF_PROTO2 = 0x4000        /* protocol specific routing flag */
let    RTF_PROTO1 = 0x8000        /* protocol specific routing flag */

let    RTF_PRCLONING = 0x10000        /* protocol requires cloning */
let    RTF_WASCLONED = 0x20000        /* route generated through cloning */
let    RTF_PROTO3 = 0x40000        /* protocol specific routing flag */
                    /* 0x80000 unused */
let    RTF_PINNED = 0x100000    /* future use */
let    RTF_LOCAL = 0x200000    /* route represents a local address */
let    RTF_BROADCAST = 0x400000    /* route represents a bcast address */
let    RTF_MULTICAST = 0x800000    /* route represents a mcast address */
let    RTF_IFSCOPE = 0x1000000    /* has valid interface scope */
let    RTF_CONDEMNED = 0x2000000    /* defunct; no longer modifiable */
let    RTF_IFREF = 0x4000000    /* route holds a ref to interface */
let    RTF_PROXY = 0x8000000    /* proxying, no interface scope */
let    RTF_ROUTER = 0x10000000    /* host is a router */
                    /* 0x20000000 and up unassigned */



/*
 * Routing statistics.
 */
struct    rtstat {
    var    rts_badredirect:Int16    /* bogus redirect calls */
    var    rts_dynamic:Int16       /* routes created by redirects */
    var    rts_newgateway:Int16        /* routes modified by redirects */
    var    rts_unreach:Int16        /* lookups which failed */
    var    rts_wildcard:Int16       /* lookups satisfied by a wildcard */
}

/*
 * Structures for routing messages.
 */
struct rt_msghdr {
    var    rtm_msglen:UInt16    /* to skip over non-understood messages */
    var    rtm_version:CUnsignedChar    /* future binary compatibility */
    var    rtm_type:CUnsignedChar    /* message type */
    var    rtm_index:UInt16     /* index for associated ifp */
    var    rtm_flags:Int    /* flags, incl. kern & message, e.g. DONE */
    var    rtm_addrs:Int    /* bitmask identifying sockaddrs in msg */
    var    rtm_pid:pid_t    /* identify sender */
    var    rtm_seq:Int    /* for sender to identify action */
    var    rtm_errno:Int    /* why failed */
    var    rtm_use:Int    /* from rtentry */
    var rtm_inits:UInt32    /* which metrics we are initializing */
    var rtm_rmx: rt_metrics /* metrics themselves */
}


struct rt_msghdr2 {
    var    rtm_msglen:UInt16    /* to skip over non-understood messages */
    var    rtm_version:CUnsignedChar    /* future binary compatibility */
    var    rtm_type:CUnsignedChar    /* message type */
    var    rtm_index:UInt16     /* index for associated ifp */
    var    rtm_flags:Int    /* flags, incl. kern & message, e.g. DONE */
    var    rtm_addrs:Int    /* bitmask identifying sockaddrs in msg */
    var    rtm_refcnt:Int32    /* reference count */
    var    rtm_parentflags:Int /* flags of the parent route */
    var    rtm_reserved:Int    /* reserved field set to 0 */
    var    rtm_use:Int    /* from rtentry */
    var rtm_inits:UInt32    /* which metrics we are initializing */
    var rtm_rmx: rt_metrics ; /* metrics themselves */
}




let    RTM_VERSION  =  5    /* Up the ante and ignore older versions */

/*
 * Message types.
 */
let    RTM_ADD = 0x1    /* Add Route */
let    RTM_DELETE = 0x2    /* Delete Route */
let    RTM_CHANGE = 0x3    /* Change Metrics or flags */
let    RTM_GET = 0x4    /* Report Metrics */
let    RTM_LOSING = 0x5    /* RTM_LOSING is no longer generated by xnu
                   and is deprecated */
let    RTM_REDIRECT = 0x6    /* Told to use different route */
let    RTM_MISS = 0x7    /* Lookup failed on this address */
let    RTM_LOCK = 0x8    /* fix specified metrics */
let    RTM_OLDADD = 0x9    /* caused by SIOCADDRT */
let    RTM_OLDDEL = 0xa    /* caused by SIOCDELRT */
let    RTM_RESOLVE = 0xb    /* req to resolve dst to LL addr */
let    RTM_NEWADDR = 0xc    /* address being added to iface */
let    RTM_DELADDR = 0xd    /* address being removed from iface */
let    RTM_IFINFO = 0xe    /* iface going up/down etc. */
let    RTM_NEWMADDR = 0xf    /* mcast group membership being added to if */
let    RTM_DELMADDR = 0x10    /* mcast group membership being deleted */
let    RTM_IFINFO2 = 0x12    /* */
let    RTM_NEWMADDR2 = 0x13    /* */
let    RTM_GET2 = 0x14    /* */

/*
 * Bitmask values for rtm_inits and rmx_locks.
 */
let    RTV_MTU = 0x1    /* init or lock _mtu */
let    RTV_HOPCOUNT = 0x2    /* init or lock _hopcount */
let    RTV_EXPIRE = 0x4    /* init or lock _expire */
let    RTV_RPIPE = 0x8    /* init or lock _recvpipe */
let    RTV_SPIPE = 0x10    /* init or lock _sendpipe */
let    RTV_SSTHRESH = 0x20    /* init or lock _ssthresh */
let    RTV_RTT = 0x40    /* init or lock _rtt */
let    RTV_RTTVAR = 0x80    /* init or lock _rttvar */

/*
 * Bitmask values for rtm_addrs.
 */
let    RTA_DST        = 0x1    /* destination sockaddr present */
let    RTA_GATEWAY    = 0x2    /* gateway sockaddr present */
let    RTA_NETMASK    = 0x4    /* netmask sockaddr present */
let    RTA_GENMASK    = 0x8    /* cloning mask sockaddr present */
let    RTA_IFP        = 0x10    /* interface name sockaddr present */
let    RTA_IFA        = 0x20    /* interface addr sockaddr present */
let    RTA_AUTHOR     = 0x40    /* sockaddr for author of redirect */
let    RTA_BRD        = 0x80    /* for NEWADDR, broadcast or p-p dest addr */

/*
 * Index offsets for sockaddr array for alternate internal encoding.
 */
let    RTAX_DST =  0    /* destination sockaddr present */
let    RTAX_GATEWAY = 1    /* gateway sockaddr present */
let    RTAX_NETMASK = 2    /* netmask sockaddr present */
let    RTAX_GENMASK = 3    /* cloning mask sockaddr present */
let    RTAX_IFP = 4    /* interface name sockaddr present */
let    RTAX_IFA = 5    /* interface addr sockaddr present */
let    RTAX_AUTHOR = 6    /* sockaddr for author of redirect */
let    RTAX_BRD = 7    /* for NEWADDR, broadcast or p-p dest addr */
let    RTAX_MAX = 8    /* size of array to allocate */

struct rt_addrinfo {
    var    rti_addrs: Int
    var    rti_info: [sockaddr]
}


